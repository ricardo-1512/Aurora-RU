<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AURORA X — Robuste Version (v8)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{ --bg:#050505; }
    body{ background:var(--bg); color:#fff; font-family: ui-sans-serif, system-ui, -apple-system; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Consolas, monospace; }

    .glass{
      background:
        radial-gradient(1200px 500px at 20% -10%, rgba(34,197,94,.15), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
    }

    .card{
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      box-shadow: 0 18px 55px rgba(0,0,0,.35);
    }

    .badge{
      border:1px solid rgba(255,255,255,.1);
      background: rgba(0,0,0,.3);
      border-radius:999px;
      padding:.2rem .5rem;
      font-size:10px;
      letter-spacing:.12em;
      text-transform: uppercase;
      color: rgba(255,255,255,.65);
      white-space: nowrap;
    }

    .glow-red{ color:#ef4444; text-shadow: 0 0 20px rgba(239, 68, 68, .5); }
    .glow-yellow{ color:#f59e0b; text-shadow: 0 0 20px rgba(245, 158, 11, .4); }
    .glow-green{ color:#22c55e; text-shadow: 0 0 20px rgba(34, 197, 94, .4); }

    .btn-primary{ background: #22c55e; color:#052e16; font-weight: 800; }
    .btn-primary:hover{ filter: brightness(1.05); }

    .input{
      background: rgba(0,0,0,.5);
      border:1px solid rgba(255,255,255,.1);
      border-radius: 10px;
      padding: 8px 12px;
      color: #fff;
      outline: none;
    }

    #map{
      height: 210px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.1);
      overflow:hidden;
    }

    .chart-wrap{
      height: 200px;
      width:100%;
      position:relative;
    }

    /* Fix: prevents the “chart grows longer and longer” bug on some mobiles */
    canvas{
      width:100% !important;
      height:100% !important;
      display:block;
    }
  </style>
</head>

<body class="p-4">
  <div class="max-w-2xl mx-auto">

    <!-- Header -->
    <div class="glass rounded-2xl p-5 mb-4">
      <div class="flex justify-between items-start mb-4">
        <div>
          <h1 class="text-xl font-black">AURORA <span class="text-green-400">X</span></h1>
          <div class="flex items-center gap-2 mt-2">
            <span class="badge" id="statusBadge">CHECKING…</span>
            <span class="badge">Lat: <span class="mono" id="latText">50.83</span></span>
            <span class="badge">Lon: <span class="mono" id="lonText">12.92</span></span>
          </div>
        </div>
        <div class="text-right text-[10px] text-white/40 mono">
          <div>Letztes Update</div>
          <div id="updateTime">--:--</div>
        </div>
      </div>

      <div class="flex gap-2">
        <input id="placeInput" class="input flex-grow text-sm" placeholder="Ort suchen… (optional)">
        <button class="btn-primary px-4 py-2 rounded-xl text-xs" id="btnUpdate">UPDATE</button>
      </div>

      <div class="text-[11px] text-white/45 mt-3">
        Tipp: Zieh den Pin auf einen dunkleren Spot außerhalb der Stadt und prüf dort Wolken.
      </div>
    </div>

    <!-- Map directly under header (as you wanted) -->
    <div class="card p-4 mb-4">
      <div class="flex justify-between items-center mb-3">
        <div class="text-[10px] text-white/40 font-bold uppercase tracking-widest">Standort-Pin (draggable)</div>
        <span class="badge">Night Map</span>
      </div>
      <div id="map"></div>
    </div>

    <!-- Decision -->
    <div class="card p-8 text-center mb-4">
      <div id="mainStatus" class="text-6xl font-black tracking-tighter mb-2 text-white/20">ANALYSE</div>
      <p id="mainRec" class="text-sm text-white/50 italic">Daten werden abgefragt…</p>

      <div class="flex flex-wrap justify-center gap-2 mt-6">
        <span class="badge">Bz: <span id="chipBz" class="mono">--</span></span>
        <span class="badge">Spd: <span id="chipSpd" class="mono">--</span></span>
        <span class="badge">Kp: <span id="chipKp" class="mono">--</span></span>
        <span class="badge">Cloud: <span id="chipCloud" class="mono">--</span></span>
      </div>
    </div>

    <!-- Small cards -->
    <div class="grid grid-cols-2 gap-3 mb-4">
      <div class="card p-4">
        <div class="text-[10px] text-white/40 uppercase font-bold mb-1">Sonnenwind</div>
        <div class="text-2xl font-bold mono" id="valSpd">--</div>
        <div class="text-[10px] text-white/30 italic">km/s</div>
      </div>
      <div class="card p-4">
        <div class="text-[10px] text-white/40 uppercase font-bold mb-1">Magnetfeld</div>
        <div class="text-2xl font-bold mono" id="valBz">--</div>
        <div class="text-[10px] text-white/30 italic">nT (Süd-Ausrichtung)</div>
      </div>
    </div>

    <!-- Chart -->
    <div class="card p-4 mb-4">
      <div class="flex justify-between items-center mb-3">
        <div class="text-[10px] text-white/40 font-bold uppercase tracking-widest">Bz & Speed Verlauf (letzte ~60 Min)</div>
        <span class="badge">Filtered • aligned</span>
      </div>
      <div class="chart-wrap">
        <canvas id="chartMain"></canvas>
      </div>
    </div>

  </div>

  <script>
    let currentLat = 50.83, currentLon = 12.92;
    let chartMain = null;
    let map, marker;

    const $ = id => document.getElementById(id);

    function nowHHMM() {
      return new Date().toLocaleTimeString("de-DE", { hour: "2-digit", minute: "2-digit" });
    }

    function safeNum(x) {
      const n = parseFloat(x);
      return Number.isFinite(n) ? n : null;
    }

    async function fetchJson(url, timeoutMs = 12000) {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { cache: "no-store", signal: controller.signal });
        if (!res.ok) return null;
        return await res.json();
      } catch {
        return null;
      } finally {
        clearTimeout(t);
      }
    }

    // Robust: scan backwards until you find a finite number
    function findLastValid(data, index) {
      if (!data || !Array.isArray(data) || data.length < 2) return null;
      for (let i = data.length - 1; i >= 1; i--) {
        const row = data[i];
        if (!Array.isArray(row) || row.length <= index) continue;
        const val = safeNum(row[index]);
        if (val !== null) return { val, time: row[0] };
      }
      return null;
    }

    // Build timestamp->speed map for alignment (NO index-matching!)
    function buildSpeedMap(plasma) {
      const m = new Map();
      if (!plasma || !Array.isArray(plasma)) return m;
      for (let i = 1; i < plasma.length; i++) {
        const row = plasma[i];
        if (!Array.isArray(row) || row.length < 3) continue;
        const t = row[0];
        const spd = safeNum(row[2]);
        m.set(t, spd);
      }
      return m;
    }

    function isoToHHMMSS(iso) {
      if (!iso) return "";
      const t = (iso.split(" ")[1] || "");
      return t.slice(0, 8); // HH:MM:SS (prevents duplicate x labels)
    }

    function setBadge(mode) {
      const b = $("statusBadge");
      b.className = "badge";
      if (mode === "LIVE") b.textContent = "LIVE";
      else if (mode === "DEGRADED") b.textContent = "DEGRADED";
      else if (mode === "OFFLINE") b.textContent = "OFFLINE";
      else b.textContent = "CHECKING…";
    }

    function setMainStatus(level, text) {
      const el = $("mainStatus");
      el.className = "text-6xl font-black tracking-tighter mb-2";
      if (level === "ALARM") { el.textContent = "ALARM"; el.classList.add("glow-red"); }
      else if (level === "CHANCE") { el.textContent = "CHANCE"; el.classList.add("glow-yellow"); }
      else if (level === "WATCH") { el.textContent = "WATCH"; el.classList.add("glow-green"); }
      else { el.textContent = "RUHIG"; el.classList.add("text-white/20"); }
      $("mainRec").textContent = text || "";
    }

    async function update() {
      setBadge("CHECK");
      $("updateTime").textContent = nowHHMM();

      // 1) Pull feeds in parallel
      const [magData, plasmaData, kpData] = await Promise.all([
        fetchJson("https://services.swpc.noaa.gov/products/solar-wind/mag-1-day.json", 15000),
        fetchJson("https://services.swpc.noaa.gov/products/solar-wind/plasma-1-day.json", 15000),
        fetchJson("https://services.swpc.noaa.gov/products/noaa-planetary-k-index-1-day.json", 15000)
      ]);

      // 2) Extract last valid values
      const bzObj = findLastValid(magData, 3);
      const spdObj = findLastValid(plasmaData, 2);
      const kpObj = findLastValid(kpData, 1);

      const bz = bzObj ? bzObj.val : null;
      const spd = spdObj ? spdObj.val : null;
      const kp  = kpObj  ? kpObj.val  : null;

      // 3) Weather (cloud cover)
      let cloud = null;
      const wx = await fetchJson(`https://api.open-meteo.com/v1/forecast?latitude=${currentLat}&longitude=${currentLon}&current=cloud_cover`, 10000);
      if (wx && wx.current && Number.isFinite(wx.current.cloud_cover)) cloud = wx.current.cloud_cover;

      // 4) UI update
      $("valBz").textContent = (bz !== null) ? bz.toFixed(1) : "--";
      $("valSpd").textContent = (spd !== null) ? Math.round(spd) : "--";

      $("chipBz").textContent = (bz !== null) ? bz.toFixed(1) : "--";
      $("chipSpd").textContent = (spd !== null) ? Math.round(spd) : "--";
      $("chipKp").textContent  = (kp !== null)  ? kp.toFixed(1) : "--";
      $("chipCloud").textContent = (cloud !== null) ? `${cloud}%` : "--";

      const hasAny = (bz !== null) || (spd !== null) || (kp !== null) || (cloud !== null);
      const hasCore = (bz !== null) && (spd !== null); // your core decision data

      if (!hasAny) setBadge("OFFLINE");
      else if (!hasCore) setBadge("DEGRADED");
      else setBadge("LIVE");

      // 5) Decision logic (safe)
      if (bz !== null && spd !== null && bz <= -10 && spd >= 500) {
        setMainStatus("ALARM", "Hervorragende Werte! Geh raus (Norden, Langzeitbelichtung).");
      } else if ((bz !== null && bz <= -4) || (kp !== null && kp >= 4)) {
        setMainStatus("CHANCE", "Beobachten! Es tut sich was. Check auch OVATION + Magnetometer.");
      } else if (bz !== null || spd !== null || kp !== null) {
        setMainStatus("RUHIG", "Aktuell keine signifikante Aktivität.");
      } else {
        setMainStatus("RUHIG", "Keine Daten (Feed/Netzwerk). Refresh probieren.");
      }

      if (cloud !== null && cloud > 80) {
        $("mainRec").textContent += " (Aber sehr bewölkt!)";
      } else if (cloud !== null && cloud < 25) {
        $("mainRec").textContent += " (Wolken sehr gut!)";
      }

      // 6) Chart update (FIXED: nulls + timestamp alignment)
      renderChart(magData, plasmaData);
    }

    function renderChart(mag, plasma) {
      if (!mag || !plasma || !Array.isArray(mag) || !Array.isArray(plasma)) return;

      const ctx = $("chartMain").getContext("2d");
      const labels = [], bzData = [], spdData = [];

      const speedMap = buildSpeedMap(plasma);

      // take last 70 mag points; later we cut to 40 valid points
      const sliceMag = mag.slice(-70);

      for (let i = 0; i < sliceMag.length; i++) {
        const row = sliceMag[i];
        if (!Array.isArray(row) || row.length < 4) continue;

        const iso = row[0];
        const time = isoToHHMMSS(iso); // ✅ prevents duplicate labels
        const bzVal = safeNum(row[3]);

        // align speed by SAME timestamp (best effort)
        const spdVal = speedMap.has(iso) ? speedMap.get(iso) : null;

        labels.push(time);

        // ✅ your proposed logic: keep point but null if invalid
        bzData.push(Number.isFinite(bzVal) ? bzVal : null);
        spdData.push(Number.isFinite(spdVal) ? spdVal : null);
      }

      // keep last ~40 points for readability
      const cut = Math.max(0, labels.length - 40);
      const L = labels.slice(cut);
      const B = bzData.slice(cut);
      const S = spdData.slice(cut);

      if (chartMain) chartMain.destroy();
      chartMain = new Chart(ctx, {
        type: 'line',
        data: {
          labels: L,
          datasets: [
            {
              label: 'Bz (nT)',
              data: B,
              borderColor: '#3b82f6',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.25,
              yAxisID: 'y',
              spanGaps: false   // ✅ do not connect across nulls
            },
            {
              label: 'Speed (km/s)',
              data: S,
              borderColor: '#ef4444',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.25,
              yAxisID: 'y1',
              spanGaps: false   // ✅ do not connect across nulls
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: { legend: { display: false } },
          scales: {
            x: {
              ticks: { color: 'rgba(255,255,255,0.45)', maxTicksLimit: 7 },
              grid: { color: 'rgba(255,255,255,0.05)' }
            },
            y: {
              position: 'left',
              ticks: { color: 'rgba(255,255,255,0.45)' },
              grid: { color: 'rgba(255,255,255,0.05)' }
            },
            y1: {
              position: 'right',
              ticks: { color: 'rgba(255,255,255,0.45)' },
              grid: { display: false }
            }
          }
        }
      });
    }

    // Map init (dark tiles)
    function initMap() {
      map = L.map('map', { zoomControl: false }).setView([currentLat, currentLon], 10);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap &copy; CARTO',
        subdomains: 'abcd',
        maxZoom: 20
      }).addTo(map);

      marker = L.marker([currentLat, currentLon], { draggable: true }).addTo(map);
      marker.on('dragend', () => {
        const p = marker.getLatLng();
        currentLat = p.lat;
        currentLon = p.lng;
        $("latText").textContent = currentLat.toFixed(2);
        $("lonText").textContent = currentLon.toFixed(2);
        update();
      });
    }

    $("btnUpdate").onclick = update;
    initMap();
    update();
    setInterval(update, 60000);
  </script>
</body>
</html>
